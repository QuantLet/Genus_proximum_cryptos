[<img src="https://github.com/QuantLet/Styleguide-and-FAQ/blob/master/pictures/banner.png" width="888" alt="Visit QuantNet">](http://quantlet.de/)

## [<img src="https://github.com/QuantLet/Styleguide-and-FAQ/blob/master/pictures/qloqo.png" alt="Visit QuantNet">](http://quantlet.de/) **SFA_cryptos** [<img src="https://github.com/QuantLet/Styleguide-and-FAQ/blob/master/pictures/QN2.png" width="60" alt="Visit QuantNet 2.0">](http://quantlet.de/)

```yaml

Name of Quantlet: SFA_cryptos

Published in: Genus_proximum_cryptos

Description: 'Performes Factor Analysis on a dataset of 23 variables, describing cryptos, stocks, FX and commodities.'

Keywords: cryptocurrency, genus proximum, classiffication, multivariate analysis, factor models
 
Author: Daniel Traian Pele

See also: FA_cryptos, DFA_cryptos

Submitted: 2019-03-21

Datafiles: 'factor_an_static.m, stats_static.mat'

Example: Run the code and get the projection on the 3 main factors

```

![Picture1](factors_1.png)

![Picture2](factors_2.png)

![Picture3](factors_3.png)

![Picture4](scores_1.png)

![Picture5](scores_2.png)

![Picture6](scores_3.png)

![Picture7](scree_plot.png)

### MATLAB Code
```matlab

%% Factor modelling of assets

%% Global Commands


clear;clc;

% specify directoy for the files
directory='D:\PROIECTE\Cryptos 2019\Data';
addpath(genpath(directory));
cd(directory);



%set global commands for font size and line width
size_font=9;
size_line=1.5;
set(0,'DefaultAxesFontSize',size_font,'DefaultTextFontSize',size_font);
set(0,'defaultlinelinewidth',size_line)

% figures
set(0, 'defaultFigurePapertype', 'A4');
set(0, 'defaultFigurePaperUnits', 'centimeters');
set(0, 'defaultFigurePaperPositionMode', 'auto');
figure_wide=[680 678 800 420];

% colors
color_blue=[0 102 204]./255;
color_green=[0 204 102]./255;
color_red=[204 0 0]./255;
color_black=[0 0 0];

% reset rngs before running
rng(1)

%% Data

%% Import data from text file.
% Script for importing data from the following text file:
%
%    D:\PROIECTE\Cryptos 2019\Data\new_assets_2019.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2019/10/01 15:53:04

%% Initialize variables.
filename = 'D:\PROIECTE\Cryptos 2019\Data\new_assets_2019.csv';
delimiter = ',';
startRow = 2;

%% Format for each line of text:
%   column1: datetimes (%{MM/dd/yyyy}D)
%	column2: text (%q)
%   column3: text (%q)
%	column4: text (%q)
%   column5: double (%f)
%	column6: text (%q)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%{MM/dd/yyyy}D%q%q%q%f%q%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'TextType', 'string', 'EmptyValue', NaN, 'HeaderLines' ,startRow-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
Date = dataArray{:, 1};
name = dataArray{:, 2};
symbol = dataArray{:, 3};
type = dataArray{:, 4};
logreturn = dataArray{:, 5};
name_symb = dataArray{:, 6};

% For code requiring serial dates (datenum) instead of datetime, uncomment
% the following line(s) below to return the imported dates as datenum(s).

% Date=datenum(Date);


%% Clear temporary variables
clearvars filename delimiter startRow formatSpec fileID dataArray ans;
%% Unique
load crypto_rank.mat;
% unique assets

[asset_unique,index_unique]=unique(name_symb,'stable');

%% Delete assets

ind=rank(:,1)>5204;
delete=name_crypto(ind,:);
%{
for i=1:length(delete)
    
    index_del{i}=find(strcmp(delete{i},asset_unique)==1);
    asset_unique([index_del{i}])=[];
    index_unique([index_del{i}])=[];
end
%}
index_del=find(strcmp('Electra_ECA',asset_unique)==1);
index_del2=find(strcmp('NativeCoin_N8V',asset_unique)==1);
index_del3=find(strcmp('MetrixCoin_MRX',asset_unique)==1); 

index_del4=find(strcmp('UnderArmourClass_UAA',asset_unique)==1);
index_del5=find(strcmp('UnderArmourClass_UA',asset_unique)==1);
%index_del6=find(strcmp('CAFENATL_INDEX_CAFEN',asset_unique)==1);
%index_del7=find(strcmp('Tether_USDT',asset_unique)==1);
%asset_unique([index_del,index_del2,index_del3, index_del4, index_del5,index_del6, index_del7])=[];
%index_unique([index_del,index_del2,index_del3, index_del4, index_del5,index_del6, index_del7])=[];
asset_unique([index_del,index_del2,index_del3,index_del4, index_del5])=[];
index_unique([index_del,index_del2,index_del3,index_del4, index_del5])=[];
% number of assets
n_assets=length(asset_unique);
% dates numeric
date_num=datenum(Date);
[date_unique,date_indices]=sort(unique(date_num,'stable'));
t_max=length(date_unique);


% init
ret=cell(n_assets,1);
type_assets=cell(4,1); % 4 asset types

% return separately
for i=1:n_assets
    index_asset=strcmp(asset_unique(i),name_symb);
    ret{i,1}=logreturn(index_asset);
    ret{i,2}=date_num(index_asset);
    type_assets{i,1}=type{index_unique(i)};
    
end
symb_assets=symbol(index_unique);

% init
%ret_matrix=nan(t_max,n_assets);




%% Statistics

    
    % In-Sample
    stats_raw = fun_stat_static(ret,n_assets);
    



%% Subset

subset=[1:3 4 6   8:23 26:27];
%subset=[1:27];
 stats=stats_raw(:,subset);

est_labels_raw={'Variance'; 'Skewness';'Kurtosis';...
    'Stable \alpha';'Stable \beta';'Stable \gamma';...
    'Stable \delta';'Q_{5%}';'Q_{2.5%}';'Q_{1%}';'Q_{0.5%}';...
    'CTE_{5%}';'CTE_{2.5%}';'CTE_{1%}';'CTE_{0.5%}';...
    'Q_{95%}';'Q_{97.5%}';'Q_{99%}';'Q_{99.5%}';...
    'CTE_{95%}';'CTE_{97.5%}';'CTE_{99%}';'CTE_{99.5%}';...
    'ACF Lag 1'; 'Hurst';'GARCH parameter';'ARCH parameter'};
est_labels=est_labels_raw(subset,1);


index_crypto=strcmp(type_assets,'Crypto');

Check = {'BTC','ETH','XRP','BCH','LTC','USDT',	'BNB','EOS','BSV','XMR'}';  

Match=cellfun(@(x) ismember(x, Check), symb_assets, 'UniformOutput', 0);
index_show=find(cell2mat(Match));


%% Corr

h=figure();
Rho=corr(stats);
Sigma=cov(stats);
imagesc(Rho);
colormap(coolwarm);
set(gca,'YTick',[1:length(est_labels)],'YTickLabel',est_labels, 'FontSize', 10);
set(gca,'XTick',[1:length(est_labels)],'XTickLabel',est_labels, 'FontSize', 10);
xtickangle(90);
colorbar();
%print(h,'-depsc','-r300','stats_corr') %-depsc


%% Eigenvalues
h=figure();
Eig=eig(Rho);
pareto(Eig);
xlabel('Factors')
ylabel('Eigenvalue')

%print(h,'-depsc','-r300','class_vari') %-depsc

%% Factor model

[loadings,F,f2] = factor_an_static(stats);

h=figure();
imagesc(loadings)
colormap(coolwarm)
xlabel('Factor')
ylabel('Loading')
set(gca,'YTick',[1:length(F)],'YTickLabel',est_labels, 'FontSize', 10);
colorbar()
set(gca,'XTick',[1:3])
%print(h,'-depsc','-r300','class_rota') %-depsc

%% plot, correlation of the original variable with the PCs

figure
hold on
xlim([-1.2 1.2])
ylim([-1.2 1.2])
line([-1.2 1.2],[0 0],'Color','k')
line([0 0],[1.2 -1.2],'Color','k')

xlabel('Tail Factor')
ylabel('Moment Factor')
daspect([1,1,1])
plot(exp((-1)^.5*[0:2*pi/360:2*pi]))        % plot unit circle
box on
rgb=[0 0 1];
scatter(loadings(:,1),loadings(:,2), 'Filled');
textfit(loadings(:,1),loadings(:,2),est_labels);
hold off;


figure
hold on
xlim([-1.2 1.2])
ylim([-1.2 1.2])
line([-1.2 1.2],[0 0],'Color','k')
line([0 0],[1.2 -1.2],'Color','k')

xlabel('Tail Factor')
ylabel('GARCH factor')
daspect([1,1,1])
plot(exp((-1)^.5*[0:2*pi/360:2*pi]))        % plot unit circle
box on
rgb=[0 0 1];
scatter(loadings(:,1),loadings(:,3), 'Filled');
textfit(loadings(:,1),loadings(:,3),est_labels);
hold off;

figure
hold on
xlim([-1.2 1.2])
ylim([-1.2 1.2])
line([-1.2 1.2],[0 0],'Color','k')
line([0 0],[1.2 -1.2],'Color','k')

xlabel('Moment Factor')
ylabel('GARCH factor')
daspect([1,1,1])
plot(exp((-1)^.5*[0:2*pi/360:2*pi]))        % plot unit circle
box on
rgb=[0 0 1];
scatter(loadings(:,2),loadings(:,3), 'Filled');
textfit(loadings(:,2),loadings(:,3),est_labels);
hold off;

%% Scores

index_crypto=strcmp(type_assets,'Crypto');

Check = {'BTC','ETH','XRP','BCH','LTC','USDT',	'BNB','EOS','BSV','XMR'}';  

Match=cellfun(@(x) ismember(x, Check), symb_assets, 'UniformOutput', 0);
index_show=find(cell2mat(Match));
%user_factor=2
for user_factor=2:3
color_assets=nan(n_assets,3);
color_crypto=nan(n_assets,3);
[~,index_type_raw]=unique(type_assets,'stable');
index_type=[index_type_raw; n_assets];
n_types=length(index_type(1:end-1));

for i=1:n_assets
    if strcmp(type_assets{i},'Crypto')==1
        color_assets(i,:)=color_green;
        color_crypto(i,:)=color_green;
    elseif strcmp(type_assets{i},'Stock')==1
        color_assets(i,:)=color_black;
        color_crypto(i,:)=color_black;
    elseif strcmp(type_assets{i},'Exchange rate')==1
        color_assets(i,:)=color_blue;
        color_crypto(i,:)=color_black;
    elseif strcmp(type_assets{i},'Commodity')==1
        color_assets(i,:)=color_red;
        color_crypto(i,:)=color_black;
    end
end

h=figure();
scatter(F(:,1),F(:,user_factor),[],color_assets,'filled')
text_delta=0.03;

text(F(index_show,1)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));

xlabel('Tail factor');
if user_factor==2
    ylabel('Moment factor');
elseif user_factor==3
    ylabel('GARCH factor');
end

hold on

for i=1:n_types

    if i==1
        user_color=color_red;
    elseif i==2
        user_color=color_green;
    elseif i==3
        user_color=color_blue;
    elseif i==4
        user_color=color_black;
    end
x=[F(index_type(i):index_type(i+1)-1,1),...
    F(index_type(i):index_type(i+1)-1,user_factor)];

grid_add=1.15;
grid_x=min(x(:,1))-grid_add:0.05:max(x(:,1)+grid_add);
grid_y=min(x(:,2))-grid_add:0.05:max(x(:,2)+grid_add);
[x1_raw,x2_raw] = meshgrid(grid_x, grid_y);
x1 = x1_raw(:);
x2 = x2_raw(:);
xi=[x1 x2];


fd=mvksdensity(x,xi,'PlotFcn','contour');

user_level=0.05;
[C,~]=contour(grid_x,grid_y,reshape(fd,length(grid_y),length(grid_x)),[user_level,user_level],...
    'color',user_color,'linewidth',1.5);
end
end
%print(h,'-depsc','-r300','['class_scat1' mat2str(user_factor)]) %-depsc

hold off

h=figure();

scatter(F(:,2),F(:,3),[],color_assets,'filled')
text_delta=0.03;
text(F(index_show,2)+text_delta,F(index_show,3),...
   symb_assets(index_show));



xlabel('Moment factor');

ylabel('GARCH factor');
hold on

for i=1:n_types

    if i==1
        user_color=color_red;
    elseif i==2
        user_color=color_green;
    elseif i==3
        user_color=color_blue;
    elseif i==4
        user_color=color_black;
    end
x=[F(index_type(i):index_type(i+1)-1,2),...
    F(index_type(i):index_type(i+1)-1,3)];

grid_add=1.15;
grid_x=min(x(:,1))-grid_add:0.05:max(x(:,1)+grid_add);
grid_y=min(x(:,2))-grid_add:0.05:max(x(:,2)+grid_add);
[x1_raw,x2_raw] = meshgrid(grid_x, grid_y);
x1 = x1_raw(:);
x2 = x2_raw(:);
xi=[x1 x2];


fd=mvksdensity(x,xi,'PlotFcn','contour');

user_level=0.05;
[C,~]=contour(grid_x,grid_y,reshape(fd,length(grid_y),length(grid_x)),[user_level,user_level],...
    'color',user_color,'linewidth',1.5);
end




%print(h,'-depsc','-r300','['class_scat1' mat2str(user_factor)]) %-depsc
%% 3d

scatter3(F(:,1),F(:,2),F(:,3),[],color_assets,'filled');

%% Logistic Regression

type_crypto=strcmp(type_assets,'Crypto');
type_crypto_mod=type_crypto+1;

    [est_reg_para,est_reg_dev,est_reg_stats]=glmfit(F(:,1),type_crypto,'binomial','link','logit');










%% Linear Classification-1

h=figure();
user_factor=2;
scatter(F(:,1),F(:,user_factor),[],color_crypto,'filled'); hold on;
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));
% Linear discriminant analysis
lda = fitcdiscr(F(:,[1 user_factor]),type_crypto);
K = lda.Coeffs(1,2).Const;
L = lda.Coeffs(1,2).Linear;

F_min=min(F(:,2))-4;
f = @(x1,x2) K + L(1)*x1 + L(2)*x2;
z=ezplot(f,[min(F(:,1)) max(F(:,1)) F_min max(F(:,2))]);
set(z,'color',color_red,'linewidth',2)

% Stats for LDA
ldaClass = resubPredict(lda);

bad = ldaClass~=type_crypto;
plot(F(bad,1), F(bad,2), 'rx'); 
if user_factor==3
    ylim([-2.5 2.5])
else
    ylim([-3 6])
end

xlim([-5 2]);
title '';
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));
xlabel('Tail Factor');ylabel('Moment Factor');
hold off;

%print(h,'-depsc','-r300','class_lin') %-depsc


%% Linear Classification-2

h=figure();
user_factor=3;
scatter(F(:,1),F(:,user_factor),[],color_crypto,'filled'); hold on;
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));
% Linear discriminant analysis
lda = fitcdiscr(F(:,[1 user_factor]),type_crypto);
K = lda.Coeffs(1,2).Const;
L = lda.Coeffs(1,2).Linear;

F_min=min(F(:,3))-4;
f = @(x1,x2) K + L(1)*x1 + L(2)*x2;
z=ezplot(f,[min(F(:,1)) max(F(:,1)) F_min max(F(:,3))]);
set(z,'color',color_red,'linewidth',2)

% Stats for LDA
ldaClass = resubPredict(lda);

bad = ldaClass~=type_crypto;
plot(F(bad,1), F(bad,3), 'rx'); 
if user_factor==2
    ylim([-2.5 2.5])
else
    ylim([-3 6])
end;
xlim([-5 2])
title '';
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,3),...
   symb_assets(index_show));
xlabel('Tail Factor');ylabel('GARCH Factor');
hold off;

%% Linear Classification-3

h=figure();
user_factor=3;
scatter(F(:,2),F(:,user_factor),[],color_crypto,'filled'); hold on;
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));
% Linear discriminant analysis
lda = fitcdiscr(F(:,[2 user_factor]),type_crypto);
K = lda.Coeffs(1,2).Const;
L = lda.Coeffs(1,2).Linear;

F_min=min(F(:,3))-4;
f = @(x1,x2) K + L(1)*x1 + L(2)*x2;
z=ezplot(f,[min(F(:,2)) max(F(:,2)) F_min max(F(:,3))]);
set(z,'color',color_red,'linewidth',2)

% Stats for LDA
ldaClass = resubPredict(lda);

bad = ldaClass~=type_crypto;
plot(F(bad,2), F(bad,3), 'rx'); 
if user_factor==2
    ylim([-2.5 2.5])
else
    ylim([-3 6])
end

 xlim([-3 2])
title '';
text_delta=0.03;
text(F(index_show,2)+text_delta,F(index_show,3),...
   symb_assets(index_show));
xlabel('Moment Factor');ylabel('GARCH Factor');
hold off;

%% Quadratic Classification
user_factor=2;
h=figure();

scatter(F(:,1),F(:,user_factor),[],color_crypto,'filled');
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));
if user_factor==3
    ylim([-2.5 2.5])
else
    ylim([-3.2 6])
end

xlim([-5 2]);
hold on;
% Quadratic discriminant analysis
lda = fitcdiscr(F(:,[1 user_factor]),type_crypto,'DiscrimType','quadratic');
K = lda.Coeffs(1,2).Const;
L = lda.Coeffs(1,2).Linear;
Q = lda.Coeffs(1,2).Quadratic;
F_min=min(F(:,2))-4;
f = @(x1,x2) K + L(1)*x1 + L(2)*x2 + Q(1,1)*x1.^2 + ...
    (Q(1,2)+Q(2,1))*x1.*x2 + Q(2,2)*x2.^2;
z = ezplot(f,[min(F(:,1)) max(F(:,1)) F_min max(F(:,2))]);
set(z,'color',color_red,'linewidth',2)


% Stats for LDA
ldaClass = resubPredict(lda);

bad = ldaClass~=type_crypto;
plot(F(bad,1), F(bad,2), 'rx');
xlabel('Tail Factor');ylabel('Moment Factor');
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,2),...
   symb_assets(index_show));

title '';

hold off;

user_factor=3;
h=figure();

scatter(F(:,1),F(:,user_factor),[],color_crypto,'filled');
text_delta=0.03;
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));
x_lim=[-5 2];
y_lim=[-4 6.5];

ylim(y_lim);
xlim(x_lim);
hold on;
% Quadratic discriminant analysis
lda = fitcdiscr(F(:,[1 user_factor]),type_crypto,'DiscrimType','quadratic');
K = lda.Coeffs(1,2).Const;
L = lda.Coeffs(1,2).Linear;
Q = lda.Coeffs(1,2).Quadratic;
F_min=min(F(:,3))-4;
f = @(x1,x2) K + L(1)*x1 + L(2)*x2 + Q(1,1)*x1.^2 + ...
    (Q(1,2)+Q(2,1))*x1.*x2 + Q(2,2)*x2.^2;
z = ezplot(f,[min(F(:,1)) max(F(:,1)) F_min max(F(:,3))]);
set(z,'color',color_red,'linewidth',2)


% Stats for LDA
ldaClass = resubPredict(lda);

bad = ldaClass~=type_crypto;
plot(F(bad,1), F(bad,3), 'rx');
xlabel('Tail Factor');ylabel('GARCH Factor');


title '';

hold off;

user_factor=3;
h=figure();

scatter(F(:,2),F(:,user_factor),[],color_crypto,'filled');
text_delta=0.03;
text(F(index_show,2)+text_delta,F(index_show,user_factor),...
   symb_assets(index_show));
x_lim=[-3 2];
y_lim=[-3 6.5];

ylim(y_lim);
xlim(x_lim);
hold on;
% Quadratic discriminant analysis
lda = fitcdiscr(F(:,[2 user_factor]),type_crypto,'DiscrimType','quadratic');
K = lda.Coeffs(1,2).Const;
L = lda.Coeffs(1,2).Linear;
Q = lda.Coeffs(1,2).Quadratic;
F_min=min(F(:,3))-4;
f = @(x1,x2) K + L(1)*x1 + L(2)*x2 + Q(1,1)*x1.^2 + ...
    (Q(1,2)+Q(2,1))*x1.*x2 + Q(2,2)*x2.^2;
z = ezplot(f,[min(F(:,2)) max(F(:,2)) F_min max(F(:,3))]);
set(z,'color',color_red,'linewidth',2)


% Stats for LDA
ldaClass = resubPredict(lda);

bad = ldaClass~=type_crypto;
plot(F(bad,2), F(bad,3), 'rx');
xlabel('Moment Factor');ylabel('GARCH Factor');


title '';

hold off;
%print(h,'-depsc','-r300','class_quadr') %-depsc


%% SVM1
user_factor=2;
% train
cl = fitcsvm(F(:,1:2),type_crypto,'KernelFunction','rbf',...
    'BoxConstraint',Inf,'ClassNames',[0,1]);
F_min=min(F(:,2))-4;
% Predict scores over the grid

grid_add=2.15;

d = 0.05;
[x1Grid,x2Grid] = meshgrid(min(F(:,1)-grid_add):d:max((F(:,1)+grid_add)),...
    min(F(:,2)-grid_add):d:max((F(:,2)+grid_add)));
xGrid = [x1Grid(:),x2Grid(:)];
[~,scores] = predict(cl,xGrid);

h=figure();
text_delta=0.02;
z(1:2) = scatter(F(:,1),F(:,user_factor),[],color_crypto,'filled');
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
    symb_assets(index_show));
if user_factor==3
    ylim([-2.5 2.5])
else
    ylim([-3 6])
end

xlim([-5 3]);


hold on
%z(3) = plot(F(cl.IsSupportVector,1),F(cl.IsSupportVector,2),'ko');
contour(x1Grid,x2Grid,reshape(scores(:,2),size(x1Grid)),[0 0],'color',color_red,'linewidth',2);

title('');
xlabel('Tail Factor');ylabel('Moment Factor');
hold off
%print(h,'-depsc','-r300','class_svm') %-depsc
SVM = fitcsvm(F(:,1:2),type_crypto,'KernelFunction','rbf',...
    'BoxConstraint',Inf,'ClassNames',[0,1]);
SVMM = fitPosterior(SVM);


%% SVM2
user_factor=3;
% train
cl = fitcsvm(F(:,[1 user_factor]),type_crypto,'KernelFunction','rbf',...
    'BoxConstraint',Inf,'ClassNames',[0,1]);
F_min=min(F(:,3))-4;
% Predict scores over the grid

grid_add=2.15;

d = 0.05;
[x1Grid,x2Grid] = meshgrid(min(F(:,1)-grid_add):d:max((F(:,1)+grid_add)),...
    min(F(:,3)-grid_add):d:max((F(:,3)+grid_add)));
xGrid = [x1Grid(:),x2Grid(:)];
[~,scores] = predict(cl,xGrid);

h=figure();
text_delta=0.02;
z(1:2) = scatter(F(:,1),F(:,user_factor),[],color_crypto,'filled');
text(F(index_show,1)+text_delta,F(index_show,user_factor),...
    symb_assets(index_show));
x_lim=[-5 4];
y_lim=[-3 4];

ylim(y_lim);
xlim(x_lim);
hold on
%z(3) = plot(F(cl.IsSupportVector,1),F(cl.IsSupportVector,2),'ko');
contour(x1Grid,x2Grid,reshape(scores(:,2),size(x1Grid)),[0 0],'color',color_red,'linewidth',2);

title('');
xlabel('Tail Factor');ylabel('GARCH Factor');
hold off
%print(h,'-depsc','-r300','class_svm') %-depsc

%% SVM3
user_factor=3;
% train
cl = fitcsvm(F(:,[2 user_factor]),type_crypto,'KernelFunction','rbf',...
    'BoxConstraint',Inf,'ClassNames',[0,1]);
F_min=min(F(:,3))-4;
% Predict scores over the grid

grid_add=4;

d = 0.05;
[x1Grid,x2Grid] = meshgrid(min(F(:,2)-grid_add):d:max((F(:,2)+grid_add)),...
    min(F(:,3)-grid_add):d:max((F(:,3)+grid_add)));
xGrid = [x1Grid(:),x2Grid(:)];
[~,scores] = predict(cl,xGrid);

h=figure();
text_delta=0.02;
z(1:2) = scatter(F(:,2),F(:,user_factor),[],color_crypto,'filled');
text(F(index_show,2)+text_delta,F(index_show,user_factor),...
    symb_assets(index_show));
x_lim=[-3 4.5];
y_lim=[-3 4];

ylim(y_lim);
xlim(x_lim);
hold on
%z(3) = plot(F(cl.IsSupportVector,1),F(cl.IsSupportVector,2),'ko');
contour(x1Grid,x2Grid,reshape(scores(:,2),size(x1Grid)),[0 0],'color',color_red,'linewidth',2);

title('');
xlabel('Moment Factor');ylabel('GARCH Factor');
hold off
%print(h,'-depsc','-r300','class_svm') %-depsc


%% K-means
rng(1); % For reproducibility
[IDX,C,SUMD,K]=kmeans_opt(F);

[IDX,C, ~, D] = kmeans(F,K); % D is the distance of each datapoint to each of  the clusters
[minD, indMinD] = min(D); % indMinD(i) is the index (in X) of closest point to the i-th centroid
ptsymb = {'bs','r^','md','go','c+', '*','h','o','p','d','ko'};
h=figure();

for i = 1:K
    clust = find(IDX==i);
    plot3(F(clust,1),F(clust,2),F(clust,3),ptsymb{i});
    d=0.2;
   text(F(indMinD(i),1),F(indMinD(i),2),F(indMinD(i),3),...
    num2str(IDX(indMinD(i))));
     hold on
end


%plot3(cmeans2(:,1),cmeans2(:,2),cmeans2(:,3),'ko');
%plot3(cmeans2(:,1),cmeans2(:,2),cmeans2(:,3),'kx');
hold off
xlabel('Factor 1');
ylabel('Factor 2');
zlabel('Factor 3');
view(-137,10);
grid on;

Mdl = fitcecoc(F,IDX);
t = templateSVM('Standardize',true);


Mdl = fitcecoc(F,IDX,'Learners',t,...
    'ClassNames',{'1' ,'2', '3' ,'4' ,'5' ,'6', '7' ,'8','9','10'});

CVMdl = crossval(Mdl);
genError = kfoldLoss(CVMdl)

 tTree = templateTree('surrogate','on');
tEnsemble = templateEnsemble('GentleBoost',100,tTree);




h=figure();            
CVMdl = crossval(Mdl);
oofLabel = kfoldPredict(CVMdl);
predict= str2double(oofLabel);
C = confusionmat(IDX,predict);
confusionchart(C);

accuracy = sum(diag (C))/sum(C,'all');


```

automatically created on 2020-01-15